TODO list


= KERNEL:

  - copia de la memoria (para mem)

  - arreglar memory manager no buddy

  DONE:

  + semaforos

  + pipes (falta q funcione ps, pasar los prints al Userland)

  + memory 

  + process 

  + scheduling / context switch

= USERLAND:

  - sh: 

    - Deberá contar con algún mecanismo para determinar si va a ceder o no el
    foreground al proceso que se ejecuta, por ejemplo, bash ejecuta un programa
    en background cuando se agrega el símbolo “&” al final de un comando. Este
    requisito es muy importante para poder demostrar el funcionamiento del
    sistema en general ya que en la mayoría de los casos es necesario ejecutar
    más de 1 proceso.

    -  Deberá permitir conectar 2 procesos mediante un pipe, por ejemplo, bash
    hace esto al agregar el símbolo “|” entre los 2 programas a ejecutar. No es
    necesario que permita conectar más de 2 procesos con pipes, es decir, p1 |
    p2 | p3.

    - ctrl + D (envio de EOF)

  - mem: Imprime el estado de la memoria.

  - loop: Imprime su ID con un saludo cada una determinada cantidad de segundos.

  - cat: Imprime el stdin tal como lo recibe.

  - wc: Cuenta la cantidad de líneas del input.

  - phylo: Implementa el problema de los filósofos comensales... (ver consigna)

  DONE: 
  + ps (esta conectado, no imprime zombies, tmp foreground y un par de cosas mas) pasar los prints al userland para q funcione el pipeo 
  Imprime la lista de todos los procesos con sus propiedades: nombre, ID,
  prioridad, stack y base pointer, foreground y cualquier otra variable que consideren
  necesaria.

  + kill (chequear, no funciona bien)

  + nice

  + block

  + test_mm 

  + test_processes 

  + test_prio

  + test_sync

  + nueva shell de procesos (falta foreground)

  + filter


